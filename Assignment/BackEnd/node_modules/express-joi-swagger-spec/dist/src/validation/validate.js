'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const joi_1 = tslib_1.__importDefault(require("joi"));
const validation_error_1 = tslib_1.__importDefault(require("./validation-error"));
const lodash_1 = require("lodash");
const defaultOptions = {
    contextRequest: false,
    allowUnknownHeaders: true,
    allowUnknownBody: true,
    allowUnknownQuery: true,
    allowUnknownParams: true,
    allowUnknownCookies: true,
    status: 400,
    statusText: 'Bad Request',
};
let globalOptions = {};
const unknownMap = {
    headers: 'allowUnknownHeaders',
    body: 'allowUnknownBody',
    query: 'allowUnknownQuery',
    params: 'allowUnknownParams',
    cookies: 'allowUnknownCookies',
};
function expressValidation(schema) {
    if (!schema)
        throw new Error('Please provide a validation schema');
    return async (req, res, next) => {
        const errors = [];
        const options = (0, lodash_1.defaults)({}, schema.options || {}, globalOptions, defaultOptions);
        const requestInputType = ['headers', 'body', 'query', 'params', 'cookies'];
        for (let index = 0; index < requestInputType.length; index++) {
            const key = requestInputType[index];
            const allowUnknown = options[unknownMap[key]];
            const entireContext = options.contextRequest ? req : null;
            if (schema[key]) {
                await validate(errors, req[key], schema[key], key, allowUnknown, entireContext);
            }
        }
        if (errors && errors.length === 0)
            return next();
        return next(new validation_error_1.default(errors, options));
    };
}
exports.default = expressValidation;
exports.ValidationError = validation_error_1.default;
exports.options = (opts) => {
    if (!opts) {
        globalOptions = {};
        return;
    }
    globalOptions = (0, lodash_1.defaults)({}, globalOptions, opts);
};
async function validate(errObj, request, schema, location, allowUnknown, context) {
    if (!request || !schema)
        return;
    const joiOptions = {
        context: context || request,
        allowUnknown,
        abortEarly: false,
    };
    const { error, value } = await joi_1.default.object(schema).validate(request, joiOptions);
    const errors = error;
    if (!errors || errors.details.length === 0) {
        (0, lodash_1.assignIn)(request, value);
        return;
    }
    errors.details.forEach((error) => {
        const errorExists = (0, lodash_1.find)(errObj, (item) => {
            if (item && item.field === error.path && item.location === location) {
                item.messages.push(error.message);
                item.types.push(error.type);
                return item;
            }
            return;
        });
        if (!errorExists) {
            errObj.push({
                field: error.path,
                location,
                messages: [error.message],
                types: [error.type],
            });
        }
    });
    return errObj;
}
//# sourceMappingURL=validate.js.map