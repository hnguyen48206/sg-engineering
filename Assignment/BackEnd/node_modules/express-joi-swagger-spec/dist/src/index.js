"use strict";
const tslib_1 = require("tslib");
const swagger_spec_express_1 = require("swagger-spec-express");
const joi_to_swagger_1 = tslib_1.__importDefault(require("joi-to-swagger"));
const swagger_ui_express_1 = require("swagger-ui-express");
const responsesEnum_1 = tslib_1.__importDefault(require("./responsesEnum"));
const lodash_1 = require("lodash");
const validate_1 = tslib_1.__importDefault(require("./validation/validate"));
const glob_1 = require("glob");
const common_1 = require("./swagger-spec/common");
function createResponseModel({ responseModel, name }) {
    let isArray = false;
    if (responseModel && Array.isArray(responseModel) && responseModel.length) {
        isArray = true;
        responseModel = responseModel[0];
    }
    for (const property in responseModel) {
        if (typeof responseModel[property] === 'string') {
            responseModel[property] = {
                type: responseModel[property],
            };
        }
    }
    const bodyParameter = {
        type: isArray ? 'array' : 'object',
    };
    if (isArray) {
        bodyParameter.items = {
            type: 'object',
            properties: responseModel,
        };
    }
    else {
        bodyParameter.properties = responseModel;
    }
    const model = Object.assign({
        name,
    }, bodyParameter);
    (0, common_1.addModel)(model, {
        validation: 'ignore',
    });
}
function serveSwagger(app, endPoint, options, path) {
    describeSwagger(path);
    (0, swagger_spec_express_1.initialise)(app, options);
    (0, swagger_spec_express_1.compile)();
    app.use(endPoint, swagger_ui_express_1.serve, (0, swagger_ui_express_1.setup)((0, swagger_spec_express_1.json)()));
}
function createResponses(schema, responseModel, describe) {
    const responses = {
        500: {
            description: responsesEnum_1.default[500],
        },
    };
    try {
        if (responseModel && !(0, lodash_1.isEmpty)(responseModel)) {
            for (const key in responseModel) {
                if (responseModel.hasOwnProperty(key)) {
                    createResponseModel({
                        responseModel: responseModel[key],
                        name: `${schema.model}${key}ResponseModel`,
                    });
                    responses[key] = {
                        description: responsesEnum_1.default[key] ? responsesEnum_1.default[key] : '',
                        schema: {
                            $ref: `#/definitions/${schema.model}${key}ResponseModel`,
                        },
                    };
                }
            }
        }
        describe.responses = responses;
        return describe;
    }
    catch (error) {
        console.log('Error while generting response model for swagger', error);
        describe.responses = responses;
        return describe;
    }
}
function getHeader(schema, describe) {
    const arr = [];
    for (const key in schema) {
        if (schema.hasOwnProperty(key)) {
            arr.push(key);
            const query = schema[key];
            const queryObject = {
                name: key,
                type: query.type ? query.type : query,
                required: query.required === 'undefined' ? false : true,
            };
            if (query._flags && query._flags.presence) {
                queryObject.required = query._flags.presence === 'required' ? true : false;
            }
            (0, common_1.addHeaderParameter)(queryObject);
        }
    }
    if (describe.common.parameters) {
        describe.common.parameters.header = arr;
    }
    else {
        describe.common.parameters = {};
        describe.common.parameters.header = arr;
    }
    return describe;
}
function getQueryAndPathParamObj(schema, value, describe, modelName) {
    const arr = [];
    for (const key in schema) {
        if (schema.hasOwnProperty(key)) {
            arr.push(`${key}-${modelName}`);
            const query = schema[key];
            const queryObject = {
                modelName,
                name: key,
                type: query.type ? query.type : query,
                required: query.required === 'undefined' ? false : true,
            };
            if (query._flags && query._flags.presence) {
                queryObject.required = query._flags.presence === 'required' ? true : false;
            }
            value === 'query'
                ? (0, common_1.addQueryParameter)(queryObject, {
                    validation: 'ignore',
                })
                : (0, common_1.addPathParameter)(queryObject, {
                    validation: 'ignore',
                });
        }
    }
    if (describe.common.parameters) {
        value === 'query' ? (describe.common.parameters.query = arr) : (describe.common.parameters.path = arr);
    }
    else {
        describe.common.parameters = {};
        value === 'query' ? (describe.common.parameters.query = arr) : (describe.common.parameters.path = arr);
    }
    return describe;
}
function getBodyParameters(schema, describe) {
    const bodyParameter = (0, joi_to_swagger_1.default)(schema.body).swagger;
    const model = Object.assign({
        name: `${schema.model}Model`,
    }, bodyParameter);
    (0, common_1.addModel)(model, {
        validation: 'ignore',
    });
    (0, common_1.addBodyParameter)({
        name: `${schema.model}Model`,
        required: true,
        description: schema.description || undefined,
        schema: {
            $ref: `#/definitions/${schema.model}Model`,
        },
    }, {
        validation: 'ignore',
    });
    describe.common = {
        parameters: {
            body: [`${schema.model}Model`],
        },
    };
    return describe;
}
function createModel(schema, responseModel, version) {
    let tag = schema.group;
    if (version) {
        tag = `${tag}-${version}`;
    }
    let describe = {
        tags: [tag],
        common: {},
    };
    describe = {
        ...createResponses(schema, responseModel, describe),
    };
    if (schema && schema.body) {
        const bodyParams = getBodyParameters(schema, describe);
        describe = {
            ...bodyParams,
        };
    }
    if (schema && schema.query) {
        const queryParams = getQueryAndPathParamObj(schema.query, 'query', describe, schema.model);
        describe = {
            ...queryParams,
        };
    }
    if (schema && schema.path) {
        const pathParams = getQueryAndPathParamObj(schema.path, 'path', describe, schema.model);
        describe = {
            ...pathParams,
        };
    }
    if (schema && schema.header) {
        const headerParams = getHeader(schema.header, describe);
        describe = {
            ...headerParams,
        };
    }
    return describe;
}
function describeSwagger(path) {
    const { routeFolderName, responseModelFolderName, requestModelFolderName, projectRoothPath } = path;
    try {
        const routes = (0, glob_1.globSync)(`**/${routeFolderName}/**/*.js`, {
            ignore: ['index.js', '**/*.d.ts', '**/*.d.ts.map'],
            withFileTypes: true,
            cwd: projectRoothPath,
        }) || [];
        routes.forEach((file) => {
            try {
                if (!file) {
                    console.log('No router file found in given folder');
                    return;
                }
                let responseModel;
                let requestModel;
                let router = require(file.fullpath());
                const version = router.version;
                if (!router) {
                    console.log('Router missing');
                    return;
                }
                router = router.router || router;
                const requestModels = (0, glob_1.globSync)(`**/${requestModelFolderName}/**/${file.name}`, {
                    ignore: ['index.js', '**/*.d.ts', '**/*.d.ts.map'],
                    withFileTypes: true,
                    cwd: projectRoothPath,
                }) || [];
                const responseModels = (0, glob_1.globSync)(`**/${responseModelFolderName}/**/${file.name}`, {
                    ignore: ['index.js', '**/*.d.ts', '**/*.d.ts.map'],
                    withFileTypes: true,
                    cwd: projectRoothPath,
                }) || [];
                if (responseModels && responseModels[0]) {
                    responseModel = require(responseModels[0].fullpath());
                }
                else {
                    console.log('Response model  does not exist', file.name);
                }
                if (requestModels && requestModels[0]) {
                    requestModel = require(requestModels[0].fullpath());
                }
                else {
                    console.log('Request model path does not exist', file.name);
                }
                processRouter(router, requestModel, responseModel, file.name, version);
            }
            catch (error) {
                console.log(`Error in describeSwagger ${file.name}`);
            }
        });
    }
    catch (error) {
        console.log(`Error in describeSwagger ${error}`);
        return;
    }
}
function processRouter(item, requestModel, responseModel, routerName, version) {
    try {
        if (item.stack && item.stack.length > 0) {
            let count = 0;
            (0, lodash_1.map)(item.stack, (route) => {
                let routeRequestModel = (0, lodash_1.get)(requestModel, [count]);
                const routeResposeModel = (0, lodash_1.get)(responseModel, (0, lodash_1.get)(routeRequestModel, ['model']));
                if (routeRequestModel && routeRequestModel.excludeFromSwagger) {
                    count++;
                    return;
                }
                if (!routeRequestModel || !(0, lodash_1.has)(routeRequestModel, 'group')) {
                    routeRequestModel = {
                        group: routerName,
                        description: routerName,
                    };
                }
                const data = Object.assign({}, createModel(routeRequestModel, routeResposeModel, version));
                describeRouterRoute(route, data);
                count++;
                return item;
            })[0];
        }
        if (item._router) {
            describeRouterRoute(item._router, requestModel);
            return item;
        }
    }
    catch (error) {
        console.log(`Error in processRouter ${error}`);
        return;
    }
}
function describeRouterRoute(router, metaData) {
    if (metaData.described) {
        console.warn('Route already described');
        return;
    }
    if (!metaData) {
        throw new Error('Metadata must be set when calling describe');
    }
    if (!router) {
        throw new Error('router was null, either the item that swaggerize & describe was called on is not an express app/router or you have called describe before adding at least one route');
    }
    if (!router.route) {
        throw new Error('Unable to add swagger metadata to last route since the last item in the stack was not a route. Route name :' +
            router.route.name +
            '. Metadata :' +
            JSON.stringify(metaData));
    }
    const verb = Object.keys(router.route.methods)[0];
    if (!verb) {
        throw new Error("Unable to add swagger metadata to last route since the last route's methods property was empty" +
            router.route.name +
            '. Metadata :' +
            JSON.stringify(metaData));
    }
    (0, swagger_spec_express_1.ensureValid)(metaData);
    ensureAtLeastOneResponse(metaData);
    metaData.path = router.route.path;
    metaData.verb = verb;
    router.route.swaggerData = metaData;
    metaData.described = true;
}
function ensureAtLeastOneResponse(metaData) {
    if (metaData.responses && Object.keys(metaData.responses).length > 0) {
        return;
    }
    if (metaData.common && metaData.common.responses.length > 0) {
        return;
    }
    throw new Error('Each metadata description for a route must have at least one response, either specified in metaData.responses or metaData.common.responses.');
}
module.exports = {
    swaggerize: swagger_spec_express_1.swaggerize,
    createModel,
    serveSwagger,
    validation: validate_1.default,
};
//# sourceMappingURL=index.js.map